{-# LANGUAGE OverloadedLists #-}
{-# LANGUAGE QuasiQuotes #-}

module Day5Spec where

import Control.Monad (when)
import qualified Data.Text as T
import Day5
import NeatInterpolation (trimming)
import SpecUtils (shouldBePretty)
import Test.Hspec (Spec, describe, it, shouldBe, xit)
import Test.Hspec.QuickCheck
import Test.QuickCheck

simple :: T.Text
simple =
  [trimming|
    47|53
    97|13
    97|61
    97|47
    75|29

    75,47,61,53,29
    97,61,53,29,13
    75,29,13
    75,97,47,61,53
    61,13,29
    97,13,75,29,47
 |]

example :: T.Text
example =
  [trimming|
    47|53
    97|13
    97|61
    97|47
    75|29
    61|13
    75|53
    29|13
    97|29
    53|29
    61|53
    97|53
    61|29
    47|13
    75|47
    97|75
    47|61
    75|61
    47|29
    75|13
    53|13

    75,47,61,53,29
    97,61,53,29,13
    75,29,13
    75,97,47,61,53
    61,13,29
    97,13,75,29,47
 |]

spec :: Spec
spec = describe "Day 5" $ do
  it "parsing" $
    parse simple
      `shouldBePretty` Right
        ( [Rule 47 53, Rule 97 13, Rule 97 61, Rule 97 47, Rule 75 29]
        ,
          [ [75, 47, 61, 53, 29]
          , [97, 61, 53, 29, 13]
          , [75, 29, 13]
          , [75, 97, 47, 61, 53]
          , [61, 13, 29]
          , [97, 13, 75, 29, 47]
          ]
        )

  it "middle (odd list)" $ do
    middle [1, 2, 3, 4, 5] `shouldBe` Just 3

  it "middle (even list)" $ do
    middle [1, 2, 3, 4] `shouldBe` Just 3

  it "applicableRules none" $ do
    (flip applicableRules) [(1, 2), (2, 3), (3, 4), (4, 5)] [10, 11, 12] `shouldBe` []

  xit "applicableRules some (excluding this test because we do have transitive dependencies in the test input)" $ do
    (flip applicableRules) [(1, 2), (2, 3), (3, 4), (4, 5)] [1, 4, 5] `shouldBe` [(1, 2), (3, 4), (4, 5)]

  it "applicableRules both must be present" $ do
    (flip applicableRules) [(1, 2), (2, 3), (1, 4), (4, 5)] [1, 2, 3, 4, 5] `shouldBe` [(1, 2), (2, 3), (1, 4), (4, 5)]

  it "sorted list (case with transitive dependencies, and global cyclic unrelevant dependencies)" $ do
    sortByRules [(1, 2), (2, 3), (3, 4), (4, 3), (11, 10), (8, 10), (9, 11)] [2, 8, 11] `shouldBe` Right [2, 8, 11]

  it "when there are no rules, we keep the original order" $ do
    let
      input = [68, 33, 82, 65, 23, 48, 67, 17, 87]
    sortByRules [] input `shouldBe` Right input

  it "not sorted list (case with direct dependencies, and global cyclic unrelevant dependencies)" $ do
    sortByRules [(1, 2), (2, 3), (3, 4), (4, 3), (11, 10), (8, 11), (9, 11)] [2, 11, 8] `shouldBe` Right [2, 8, 11]

  xit "not sorted list (case with transitive dependencies, and global cyclic unrelevant dependencies), excluding because the exercise DOES include transitive dependencies" $ do
    sortByRules [(1, 2), (2, 3), (3, 4), (4, 3), (11, 10), (8, 10), (9, 11)] [2, 11, 8] `shouldBe` Right [2, 8, 11]

  it "a complex example with transitive cyclic dependencies, eg (96, 82), (82, 95), (95, 87), (87, 96) " $ do
    let
      rules = [(18, 68), (67, 62), (67, 41), (67, 56), (67, 37), (67, 31), (67, 52), (33, 17), (33, 25), (33, 65), (33, 53), (33, 48), (33, 94), (33, 87), (24, 48), (24, 67), (81, 23), (81, 17), (81, 67), (81, 48), (16, 68), (16, 65), (16, 23), (87, 69), (87, 62), (87, 42), (87, 32), (87, 41), (87, 36), (87, 45), (87, 26), (87, 56), (87, 31), (87, 66), (87, 77), (42, 65), (42, 33), (42, 17), (72, 68), (72, 82), (57, 48), (57, 17), (57, 68), (66, 33), (75, 87), (62, 23), (62, 65), (62, 33), (62, 82), (73, 33), (73, 68), (68, 78), (68, 67), (68, 31), (68, 25), (68, 95), (68, 23), (68, 82), (68, 14), (68, 81), (68, 33), (68, 94), (68, 48), (68, 92), (68, 47), (68, 53), (68, 37), (68, 91), (68, 44), (68, 17), (68, 75), (68, 61), (65, 47), (65, 14), (65, 73), (65, 61), (65, 81), (65, 25), (65, 44), (65, 75), (65, 67), (65, 53), (65, 18), (65, 31), (65, 64), (65, 72), (65, 48), (65, 24), (65, 94), (65, 95), (65, 37), (65, 23), (65, 17), (65, 66), (45, 68), (45, 65), (45, 82), (45, 33), (52, 33), (52, 65), (52, 82), (52, 68), (37, 87), (82, 64), (82, 94), (82, 91), (82, 25), (82, 95), (82, 31), (82, 24), (82, 67), (82, 48), (82, 65), (82, 18), (82, 73), (82, 17), (82, 75), (82, 44), (82, 53), (82, 81), (82, 37), (82, 14), (82, 23), (82, 78), (82, 87), (82, 47), (82, 61), (92, 48), (92, 87), (92, 65), (92, 17), (92, 23), (92, 82), (92, 67), (23, 31), (23, 73), (23, 67), (23, 17), (23, 61), (23, 47), (23, 25), (23, 24), (23, 66), (23, 37), (23, 48), (23, 14), (23, 44), (23, 75), (23, 72), (23, 36), (23, 56), (23, 52), (23, 45), (23, 87), (23, 53), (23, 64), (23, 94), (23, 18), (39, 33), (39, 48), (39, 82), (39, 68), (39, 65), (39, 23), (39, 67), (47, 87), (47, 17), (47, 67), (64, 68), (41, 48), (41, 82), (41, 33), (41, 23), (41, 68), (41, 65), (34, 65), (34, 68), (34, 82), (34, 33), (34, 23), (29, 65), (29, 48), (29, 68), (29, 82), (29, 23), (29, 67), (29, 33), (17, 45), (17, 34), (17, 94), (17, 64), (17, 96), (17, 52), (17, 56), (17, 41), (17, 75), (17, 87), (17, 37), (17, 39), (17, 29), (17, 69), (17, 62), (17, 66), (17, 18), (17, 16), (17, 31), (17, 73), (17, 36), (17, 61), (17, 32), (17, 72), (53, 17), (53, 48), (53, 87), (53, 67), (32, 23), (32, 68), (32, 33), (32, 65), (32, 48), (32, 67), (32, 82), (78, 48), (78, 87), (78, 67), (78, 23), (78, 65), (78, 17), (61, 87), (14, 87), (14, 17), (14, 67), (96, 68), (96, 33), (96, 65), (96, 23), (96, 82), (77, 82), (77, 33), (77, 68), (77, 65), (77, 23), (77, 67), (77, 17), (77, 48), (56, 33), (56, 68), (56, 65), (56, 82), (26, 17), (26, 82), (26, 65), (26, 23), (26, 48), (26, 68), (26, 33), (26, 67), (48, 56), (48, 45), (48, 25), (48, 47), (48, 37), (48, 31), (48, 67), (48, 96), (48, 18), (48, 44), (48, 73), (48, 36), (48, 14), (48, 61), (48, 75), (48, 87), (48, 52), (48, 17), (48, 62), (48, 72), (48, 64), (48, 94), (48, 34), (48, 66), (19, 33), (19, 82), (19, 17), (19, 68), (19, 48), (19, 23), (19, 65), (19, 67), (19, 87), (91, 67), (91, 23), (91, 17), (91, 48), (91, 87), (36, 65), (36, 33), (36, 68), (36, 82), (49, 23), (49, 68), (49, 17), (49, 33), (49, 67), (49, 48), (49, 82), (49, 65), (69, 65), (69, 33), (69, 68), (69, 48), (69, 23), (69, 82), (95, 87), (95, 48), (95, 23), (95, 67), (95, 17), (18, 33), (94, 87), (25, 17), (25, 87), (67, 94), (67, 66), (67, 18), (67, 87), (67, 96), (67, 61), (67, 75), (67, 44), (67, 25), (67, 69), (67, 73), (67, 17), (67, 34), (67, 16), (67, 45), (67, 36), (67, 64), (67, 72), (33, 64), (33, 81), (33, 91), (33, 47), (33, 67), (33, 92), (33, 31), (33, 14), (33, 61), (33, 44), (33, 23), (33, 82), (33, 24), (33, 75), (33, 95), (33, 78), (33, 37), (24, 17), (24, 87), (81, 87), (44, 87), (44, 17), (16, 82), (16, 48), (16, 33), (87, 34), (87, 72), (87, 64), (87, 39), (87, 29), (87, 49), (87, 96), (87, 18), (87, 52), (87, 57), (87, 16), (87, 73), (42, 82), (42, 68), (42, 48), (42, 67), (42, 23), (72, 33), (57, 67), (57, 33), (57, 65), (57, 82), (57, 23), (66, 68), (66, 82), (62, 68), (68, 24), (68, 65), (68, 87), (65, 91), (65, 87)]
      input = [68, 33, 82, 65, 23, 48, 67, 17, 87]
    sortByRules rules input `shouldBe` Right input

  it "answer" $ do
    logic example `shouldBe` (Right (Answer 143))

  prop "" $
    \l -> reverse (reverse l) == (l :: [Int])
